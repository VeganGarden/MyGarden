---
name: 食材规范库建设方案
overview: 建立完整的食材规范库系统，包括标准名称定义、别名映射、自动标准化流程和管理工具，从根本上解决食材重复和命名不统一的问题。
todos:
  - id: init-collections
    content: 创建ingredient_standards和ingredient_aliases集合，包括索引定义
    status: pending
  - id: migrate-fields
    content: 为ingredients集合添加standardName, alias, isStandardized等字段
    status: pending
    dependencies:
      - init-collections
  - id: standardizer-module
    content: 创建ingredient-standardizer.js标准化服务模块，实现名称标准化和别名匹配逻辑
    status: pending
    dependencies:
      - init-collections
  - id: init-standards-data
    content: 初始化规范库数据：从现有ingredients提取标准名称，生成初始别名映射
    status: pending
    dependencies:
      - standardizer-module
  - id: update-import-flow
    content: 更新import-ingredients-from-list.js，在导入时调用标准化服务
    status: pending
    dependencies:
      - standardizer-module
  - id: batch-standardize
    content: 创建批量标准化脚本，标准化所有现有ingredients数据
    status: pending
    dependencies:
      - migrate-fields
      - standardizer-module
      - init-standards-data
  - id: sync-to-factors
    content: 创建同步机制，将规范库的别名自动同步到因子库的alias字段
    status: pending
    dependencies:
      - standardizer-module
      - init-standards-data
  - id: update-carbon-matching
    content: 更新carbon/index.js中的matchFactor函数，使用标准名称进行匹配，保持向后兼容
    status: pending
    dependencies:
      - standardizer-module
      - sync-to-factors
  - id: management-tools
    content: 创建manage-ingredient-standards.js，提供规范库和别名映射的管理功能
    status: pending
    dependencies:
      - init-standards-data
---

# 食材规范库建设方案

## 目标

建立完整的食材规范库系统，通过定义标准食材名称、建立别名映射规则、实现自动标准化流程，从根本上解决食材库中重复和命名不统一的问题。

## 系统架构

### 架构关系说明

**核心设计原则**：规范库是后台支持系统，业务数据仍在 `ingredients` 库

#### 数据层次结构

```javascript
┌─────────────────────────────────────────┐
│  规范库（后台支持系统）                   │
│  - ingredient_standards (标准名称)       │
│  - ingredient_aliases (别名映射)         │
│  作用：提供标准化规则和映射关系           │
└───────────────┬─────────────────────────┘
                │ 提供标准化服务
                ↓
┌─────────────────────────────────────────┐
│  业务数据层（真正使用的数据）             │
│  - ingredients (食材库)                  │
│    ├─ name: "白菜" (原始名称)            │
│    ├─ standardName: "白菜" (标准名称)    │
│    └─ isStandardized: true              │
│                                           │
│  - recipes (食谱库)                       │
│    └─ ingredients[].name: "白菜"         │
│                                           │
│  - carbon_emission_factors (因子库)       │
│    ├─ name: "白菜" (标准名称)            │
│    └─ alias: ["大白菜","小白菜"] (别名)  │
└─────────────────────────────────────────┘
```



#### 关键设计要点

1. **ingredients 库是业务主数据**：

- 各业务板块（菜谱、碳足迹计算等）直接使用 `ingredients` 库
- `recipes` 库中的食材引用指向 `ingredients` 库的名称
- 前端查询、展示都基于 `ingredients` 库

2. **规范库是后台支持系统**：

- `ingredient_standards` 和 `ingredient_aliases` 不直接参与业务查询
- 主要作用是提供标准化规则和别名映射关系
- 通过标准化服务模块 (`ingredient-standardizer.js`) 提供服务

3. **数据流向**：

- **导入时**：新食材 → 标准化服务 → 查询/创建标准名称 → 写入 `ingredients` 库（包含 `standardName` 字段）
- **查询时**：输入名称 → 标准化服务 → 转换为标准名称 → 在 `ingredients` 库中查询
- **同步时**：规范库别名变更 → 自动同步 → `carbon_emission_factors.alias` 字段

4. **ingredients 库扩展字段**：

- `standardName`: 指向规范库中的标准名称（冗余字段，提高查询性能）
- `alias`: 原始名称作为别名（冗余字段，保持向后兼容）
- `isStandardized`: 标记是否已标准化
- 这些字段用于业务查询，但数据来源于规范库

#### 优势

- ✅ **业务独立性**：业务代码仍然直接使用 `ingredients` 库，无需大幅改造
- ✅ **数据一致性**：通过规范库统一管理标准名称和别名，避免重复
- ✅ **性能优化**：`ingredients` 库中冗余 `standardName` 字段，避免每次查询都要关联规范库
- ✅ **向后兼容**：现有业务逻辑可以继续使用 `ingredients.name` 字段

### 核心组件

1. **食材规范库集合** (`ingredient_standards`)

- 存储标准食材名称和元数据
- 定义标准分类和属性
- **角色**：后台配置数据，不直接参与业务查询

2. **别名映射集合** (`ingredient_aliases`)

- 存储别名到标准名称的映射关系
- 支持多对一映射（多个别名指向一个标准名称）
- **角色**：后台配置数据，提供别名标准化服务

3. **标准化服务模块** (`ingredient-standardizer.js`)

- 提供名称标准化功能
- 处理导入时的自动标准化
- **角色**：连接规范库和业务数据的桥梁

4. **管理工具**

- 规范库管理云函数（增删改查）
- 批量标准化现有数据
- 别名映射管理
- **角色**：管理员维护规范库的工具

## 数据模型设计

### 1. ingredient_standards 集合

```javascript
{
  _id: ObjectId,
  standardName: String,          // 标准名称（唯一）
  nameEn: String,                // 英文名称
  category: String,              // 标准分类
  subCategory: String,           // 子分类（可选）
  description: String,           // 描述
  defaultUnit: String,           // 默认单位（g, kg等）
  carbonCoefficient: Number,     // 默认碳系数（可选）
  status: String,                // active, deprecated
  version: Number,               // 版本号
  createdAt: Date,
  updatedAt: Date,
  createdBy: String,
  updatedBy: String
}
```

索引：

- `standardName_unique`: standardName (唯一索引)
- `category_index`: category
- `status_index`: status

### 2. ingredient_aliases 集合

```javascript
{
  _id: ObjectId,
  alias: String,                 // 别名
  standardName: String,          // 对应的标准名称
  confidence: Number,            // 置信度 (0-1)
  source: String,                // 来源（manual, auto, import）
  status: String,                // active, deprecated
  createdAt: Date,
  updatedAt: Date,
  createdBy: String
}
```

索引：

- `alias_standardName_index`: alias, standardName (复合索引)
- `standardName_index`: standardName
- `alias_unique`: alias (唯一索引，允许同一别名指向不同标准名称的情况需要考虑)

### 3. ingredients 集合扩展

为现有ingredients集合添加字段：

```javascript
{
  // 现有字段...
  standardName: String,          // 标准化后的名称（新增）
  alias: String,                 // 原始名称作为别名（新增）
  isStandardized: Boolean,       // 是否已标准化（新增）
  standardizedAt: Date,          // 标准化时间（新增）
}
```



## 实施步骤

### 阶段一：数据结构准备

**文件**: `cloudfunctions/database/init-ingredient-standard-collections.js`

1. 创建 `ingredient_standards` 集合
2. 创建 `ingredient_aliases` 集合
3. 为 `ingredients` 集合添加新字段（通过迁移脚本）

**文件**: `cloudfunctions/database/migrate-ingredients-add-standardization-fields.js`

- 为现有ingredients添加standardName, alias, isStandardized字段

### 阶段二：标准化服务模块

**文件**: `cloudfunctions/common/ingredient-standardizer.js`核心功能：

- `standardizeIngredientName(name)`: 将输入名称标准化
- `findStandardName(alias)`: 通过别名查找标准名称
- `findAliases(standardName)`: 查找标准名称的所有别名
- `matchIngredient(inputName)`: 智能匹配食材（支持模糊匹配）

匹配逻辑（优先级从高到低）：

1. 精确匹配标准名称
2. 精确匹配别名
3. 模糊匹配（去除修饰词后匹配）
4. 返回null（未匹配）

### 阶段三：初始化规范库数据

**文件**: `cloudfunctions/database/init-ingredient-standards-data.js`

1. 从现有ingredients提取标准名称

- 统计使用频率
- 选择最常用的作为标准名称

2. 生成初始别名映射

- 基于analyze-duplicate-ingredients的分析结果
- 手动审核和确认映射关系

3. 导入标准食材数据

- 可以从权威数据源导入
- 支持JSON/CSV格式

**数据文件**: `cloudfunctions/database/ingredient-standards-initial.json`

### 阶段四：更新导入流程

**修改文件**: `cloudfunctions/database/import-ingredients-from-list.js`在导入时：

1. 调用standardizer.standardizeIngredientName()标准化名称
2. 检查是否已存在标准名称
3. 如果不存在，创建新的标准名称记录
4. 建立别名映射关系
5. 在ingredients中保存standardName和原始名称作为alias

### 阶段五：批量标准化现有数据

**文件**: `cloudfunctions/database/migrate-standardize-existing-ingredients.js`

1. 遍历所有现有ingredients
2. 对每个食材调用标准化函数
3. 更新standardName字段
4. 在ingredient_aliases中建立映射关系
5. 更新recipes中的食材引用（可选，需要谨慎处理）

### 阶段六：与因子库和ingredients库集成和同步

**关键设计决策**：

1. 食材规范库作为统一来源，自动同步别名到因子库的alias字段
2. 食材规范库作为统一来源，自动同步standardName到ingredients库的standardName字段

**同步触发机制**：采用"函数内同步"方式，即在执行别名操作的函数中立即触发同步，而不是使用数据库触发器或定时任务。触发时机：

1. **立即同步（函数内调用）**：

- 在执行 `addAlias` 操作后，立即调用同步函数
- 在执行 `removeAlias` 操作后，立即调用同步函数
- 在执行 `mergeStandards` 操作后，立即调用同步函数
- 在执行 `updateStandard` 操作后（如果涉及别名变更），立即调用同步函数

2. **批量同步（手动触发）**：

- 提供独立的 `syncToFactors` action，用于批量同步所有数据
- 初始化数据时执行一次批量同步
- 数据修复时可以手动触发批量同步

**修改文件**: `cloudfunctions/common/ingredient-standardizer.js`新增功能：

#### 1. 同步到因子库的函数

- `syncAliasesToFactors(standardName)`: 将规范库中的别名同步到因子库（核心同步函数）
- 查找standardName对应的所有别名（从ingredient_aliases集合）
- 在carbon_emission_factors中查找name=standardName的记录（可能有多条，按region区分）
- 更新因子记录的alias字段（合并数组，保留原有的nameEn等别名）
- 返回同步结果（成功/失败统计）

同步策略：

1. 查找standardName对应的所有活跃别名（从ingredient_aliases集合，status='active'）
2. 在carbon_emission_factors中查找name=standardName的所有记录（可能有不同region）
3. 对每条因子记录：

- 保留原有的英文别名（nameEn等）
- 合并规范库中的中文别名到alias数组
- 去重处理

4. 更新因子记录的alias字段
5. 记录同步日志（成功/失败）

#### 2. 同步到ingredients库的函数

- `syncStandardNameToIngredients(oldStandardName, newStandardName)`: 将规范库中的标准名称变更同步到ingredients库
- 在ingredients集合中查找所有standardName=oldStandardName的记录
- 批量更新这些记录的standardName字段为newStandardName
- 更新isStandardized和standardizedAt字段
- 返回同步结果（更新数量、成功/失败统计）

同步策略：

1. 在ingredients集合中查找所有standardName=oldStandardName的记录
2. 批量更新这些记录：

- standardName: oldStandardName → newStandardName
- isStandardized: true（确保标记为已标准化）
- standardizedAt: 当前时间（更新时间戳）

3. 如果newStandardName为null（标准名称被废弃），可以选择：

- 保留standardName为null，isStandardized设为false
- 或者删除这些记录（需要谨慎处理）

4. 记录同步日志（更新数量、成功/失败）

**修改文件**: `cloudfunctions/database/manage-ingredient-standards.js`在以下action中调用同步函数：

```javascript
// addAlias action
async function addAlias(event) {
  // 1. 添加别名到ingredient_aliases集合
  // 2. 调用 standardizer.syncAliasesToFactors(standardName) 立即同步
  // 3. 返回结果
}

// removeAlias action  
async function removeAlias(event) {
  // 1. 从ingredient_aliases集合删除别名
  // 2. 调用 standardizer.syncAliasesToFactors(standardName) 立即同步
  // 3. 返回结果
}

// mergeStandards action
async function mergeStandards(event) {
  const { sourceStandardName, targetStandardName } = event.data;
  
  // 1. 合并标准名称（在ingredient_standards中处理）
  // 2. 更新所有相关别名映射（在ingredient_aliases中更新standardName）
  // 3. 同步到ingredients库：更新所有使用sourceStandardName的记录
  await standardizer.syncStandardNameToIngredients(sourceStandardName, targetStandardName);
  
  // 4. 同步到因子库：同步所有受影响的standardName的别名
  await standardizer.syncAliasesToFactors(targetStandardName);
  
  // 5. 返回结果
}

// updateStandard action
async function updateStandard(event) {
  const { oldStandardName, newStandardName } = event.data;
  
  // 1. 更新标准名称（在ingredient_standards中更新）
  // 2. 更新所有相关别名映射（如果standardName变更，更新ingredient_aliases）
  // 3. 同步到ingredients库：更新所有使用oldStandardName的记录
  if (oldStandardName !== newStandardName) {
    await standardizer.syncStandardNameToIngredients(oldStandardName, newStandardName);
  }
  
  // 4. 如果涉及别名变更，同步到因子库
  if (event.data.updateAliases) {
    await standardizer.syncAliasesToFactors(newStandardName);
  }
  
  // 5. 返回结果
}
```

**修改文件**: `cloudfunctions/database/sync-standard-aliases-to-factors.js`创建批量同步脚本（因子库）：

- `syncAll`: 批量同步所有标准名称的别名到因子库
- `syncByStandardName`: 同步指定标准名称的别名
- `syncIncremental`: 增量同步（只同步最近变更的，需要记录变更日志）
- 记录同步日志，便于排查问题

**修改文件**: `cloudfunctions/database/sync-standard-name-to-ingredients.js`创建批量同步脚本（ingredients库）：

- `syncAll`: 批量同步所有标准名称到ingredients库（用于修复数据不一致）
- `syncByStandardName`: 同步指定标准名称的变更到ingredients库
- `checkConsistency`: 检查ingredients库的standardName是否与规范库一致
- 记录同步日志，便于排查问题

### 阶段七：更新查询和匹配逻辑

**修改文件**: `cloudfunctions/carbon/index.js`在matchFactor函数中：

1. 先通过standardizer.standardizeIngredientName()标准化输入名称
2. 使用标准化后的名称进行匹配（优先匹配standardName）
3. 如果匹配失败，回退到原有的匹配逻辑（name和alias字段）
4. 保持向后兼容：如果规范库未启用或未找到，使用原有逻辑

匹配流程优化：

```javascript
Level 1: 使用标准化名称精确匹配因子库的name字段
Level 2: 使用标准化名称匹配因子库的alias字段（数组包含）
Level 3: 使用原始名称精确匹配因子库的name字段（向后兼容）
Level 4: 使用原始名称匹配因子库的alias字段（向后兼容）
Level 5: 类别兜底匹配
```

**修改文件**: `cloudfunctions/recipe/index.js`（如果存在）在菜谱相关的食材匹配中：

- 使用standardName进行匹配
- 支持按别名搜索食材

### 阶段七：管理工具

**文件**: `cloudfunctions/database/manage-ingredient-standards.js`提供以下action：

- `addStandard`: 添加新的标准名称
- `updateStandard`: 更新标准名称
- `addAlias`: 添加别名映射
- `removeAlias`: 删除别名映射
- `mergeStandards`: 合并两个标准名称
- `deprecateStandard`: 废弃标准名称

**文件**: `cloudfunctions/database/batch-standardize-ingredients.js`

- 批量标准化食材的云函数入口
- 支持指定条件（如分类、时间范围等）

### 阶段九：前端集成（可选）

如果需要在管理后台管理规范库：

- 创建规范库管理页面
- 提供搜索、添加、编辑功能
- 显示别名映射关系
- 提供批量操作功能

## 关键技术点

### 1. 名称标准化算法

```javascript
function standardizeIngredientName(inputName) {
  // 1. 去除前后空格
  // 2. 移除常见修饰词（新鲜、干、泡发、烤、蒸等）
  // 3. 移除后缀词（叶、根、茎、泥、汁、粉等，但要保留有意义的）
  // 4. 统一单位表示（如"克"统一为"g"）
  // 5. 查找别名映射
  // 6. 返回标准名称
}
```



### 2. 别名匹配策略

- 精确匹配优先
- 支持部分匹配（去除修饰词后）
- 支持模糊匹配（编辑距离算法，可选）
- 返回置信度评分

### 3. 数据一致性

- 标准名称变更时，同步更新所有关联数据
- 别名映射变更时，重新标准化相关食材
- 提供数据一致性检查工具

## 与因子库和ingredients库的同步关系

### 数据流向

```javascript
食材规范库 (ingredient_standards + ingredient_aliases)
    ↓ (自动同步别名)                    ↓ (自动同步standardName)
因子库 (carbon_emission_factors.alias)   ingredients库 (standardName字段)
    ↓ (匹配时使用)                      ↓ (业务查询使用)
碳足迹计算 (matchFactor函数)             菜谱、前端展示等
```



### 与因子库的集成要点

1. **统一数据源**：食材规范库是别名映射的唯一来源
2. **自动同步**：当规范库的别名映射更新时，自动同步到因子库的alias字段
3. **兼容现有逻辑**：因子库的alias字段保持数组格式，兼容现有的查询逻辑
4. **保持因子库独立性**：因子库的nameEn等字段不受影响，只同步中文别名

### 与ingredients库的同步要点

1. **统一数据源**：食材规范库是standardName的唯一来源
2. **自动同步**：当规范库的标准名称变更时，自动同步到ingredients库的standardName字段
3. **同步场景**：

- **mergeStandards（合并标准名称）**：更新ingredients库中所有使用旧standardName的记录
- **updateStandard（更新标准名称）**：更新ingredients库中所有使用该standardName的记录
- **addAlias/removeAlias（别名变更）**：通常不需要同步ingredients库（因为ingredients存储的是standardName，不是别名）

4. **保持数据一致性**：确保ingredients库的standardName字段始终与规范库保持一致

### 同步机制

**触发方式**：采用"函数内同步"模式，即在云函数的action中直接调用同步函数，而不是使用数据库触发器或定时任务。

1. **立即同步（函数内调用）**：

- **同步到因子库**：在执行 `manage-ingredient-standards.js` 的以下action时：
    - `addAlias`: 添加别名后立即调用 `syncAliasesToFactors(standardName)`
    - `removeAlias`: 删除别名后立即调用 `syncAliasesToFactors(standardName)`
    - `mergeStandards`: 合并标准名称后，同步所有受影响的standardName
    - `updateStandard`: 如果涉及别名变更，立即同步
- **同步到ingredients库**：在执行以下action时：
    - `mergeStandards`: 合并标准名称后，调用 `syncStandardNameToIngredients(sourceStandardName, targetStandardName)` 更新ingredients库
    - `updateStandard`: 如果标准名称变更，调用 `syncStandardNameToIngredients(oldStandardName, newStandardName)` 更新ingredients库
    - `addAlias` / `removeAlias`: **不需要同步**（因为ingredients库存储的是standardName，不是别名）
- 执行方式：在同一函数调用中同步执行，确保数据一致性
- 优点：实时性强，数据立即一致
- 缺点：可能增加函数执行时间（通常影响很小）

2. **批量同步（手动触发）**：

- **因子库批量同步**：通过调用 `sync-standard-aliases-to-factors.js` 的 `syncAll` action
- **ingredients库批量同步**：通过调用 `sync-standard-name-to-ingredients.js` 的 `syncAll` action
- 使用场景：
    - 初始化规范库数据后，首次批量同步所有数据
    - 数据修复时，重新同步所有数据
    - 定期维护时，确保数据一致性
- 执行方式：手动通过云函数调用或管理后台触发

**执行流程示例**：

```javascript
// 示例1: 在 manage-ingredient-standards.js 的 addAlias action 中
async function addAlias(event) {
  const { standardName, alias } = event.data;
  
  // 1. 添加别名到 ingredient_aliases 集合
  await db.collection('ingredient_aliases').add({
    data: {
      alias: alias,
      standardName: standardName,
      status: 'active',
      // ... 其他字段
    }
  });
  
  // 2. 立即同步到因子库（函数内调用）
  const syncFactorResult = await standardizer.syncAliasesToFactors(standardName);
  
  // 3. 注意：不需要同步到ingredients库（因为ingredients存储的是standardName，不是别名）
  
  // 4. 返回结果（包含同步结果）
  return {
    success: true,
    message: '别名添加成功',
    syncFactorResult: syncFactorResult  // 同步结果信息
  };
}

// 示例2: 在 manage-ingredient-standards.js 的 mergeStandards action 中
async function mergeStandards(event) {
  const { sourceStandardName, targetStandardName } = event.data;
  
  // 1. 合并标准名称（在ingredient_standards中处理）
  // 2. 更新所有相关别名映射（在ingredient_aliases中更新standardName）
  
  // 3. 同步到ingredients库：更新所有使用sourceStandardName的记录
  const syncIngredientResult = await standardizer.syncStandardNameToIngredients(
    sourceStandardName, 
    targetStandardName
  );
  
  // 4. 同步到因子库：同步所有受影响的standardName的别名
  const syncFactorResult = await standardizer.syncAliasesToFactors(targetStandardName);
  
  // 5. 返回结果
  return {
    success: true,
    message: '标准名称合并成功',
    syncIngredientResult: syncIngredientResult,  // ingredients库同步结果
    syncFactorResult: syncFactorResult  // 因子库同步结果
  };
}
```



### 同步后的数据结构

#### 因子库alias字段结构

因子库的alias字段为数组格式，同步后的结构：

```javascript
{
  name: "白菜",                    // 标准名称（从规范库同步）
  alias: [                         // 别名数组（从规范库同步所有中文别名）
    "小白菜",
    "大白菜", 
    "白菜叶",
    "圆白菜",
    "Cabbage"                      // nameEn等原有别名保持不变
  ],
  // ... 其他字段
}
```



#### ingredients库standardName字段结构

ingredients库的standardName字段在同步后的结构：

```javascript
{
  _id: ObjectId,
  name: "小白菜",                  // 原始名称（保持不变）
  standardName: "白菜",            // 标准名称（从规范库同步，mergeStandards后更新）
  alias: "小白菜",                 // 原始名称作为别名（冗余字段）
  isStandardized: true,            // 已标准化标记
  standardizedAt: Date,            // 标准化时间（同步时更新）
  // ... 其他字段（category, nameEn等）
}
```

**同步场景示例**：

1. **mergeStandards（合并标准名称）**：

- 合并前：ingredients库中有 `{name: "小白菜", standardName: "小白菜"}`
- 合并后：ingredients库中更新为 `{name: "小白菜", standardName: "白菜"}`（standardName从"小白菜"更新为"白菜"）

2. **updateStandard（更新标准名称）**：

- 更新前：ingredients库中有 `{name: "白菜", standardName: "白菜"}`
- 更新后：ingredients库中更新为 `{name: "白菜", standardName: "大白菜"}`（standardName从"白菜"更新为"大白菜"）

## 实施注意事项

1. **向后兼容**

- 保持现有API接口不变
- 新字段为可选字段，不影响现有功能
- matchFactor函数支持新旧两种匹配方式

2. **数据安全**

- 标准化前备份数据
- 提供回滚机制
- 记录所有变更操作
- 同步操作记录日志，便于追踪

3. **性能考虑**

- 为频繁查询建立索引
- 缓存标准名称和别名映射
- 批量操作时考虑分批处理
- 同步操作异步执行，避免阻塞

4. **用户体验**

- 标准化过程对用户透明
- 搜索结果同时显示标准名称和别名
- 支持按别名搜索
- 因子库匹配结果保持一致性

## 测试计划

1. 单元测试：标准化函数的各种输入情况
2. 集成测试：导入流程的标准化验证
3. 数据测试：批量标准化现有数据的准确性
4. 性能测试：查询和匹配的性能评估

## 后续优化方向

1. 机器学习辅助：使用ML模型提高别名匹配准确率