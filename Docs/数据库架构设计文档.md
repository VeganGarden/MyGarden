# 我的花园项目 - 数据库架构规划方案（简化版）

## 一、整体架构设计原则

### 1.1 核心设计目标

- **规模支持**: 10 万用户以内，日活 1-3 万
- **安全等级**: 基础保密（符合《个人信息保护法》要求）
- **读取性能**: 个人数据查询 <50ms，复杂查询 <200ms
- **数据同步**: 支持外卖平台、餐厅 POS 等第三方数据同步

### 1.2 简化设计策略

- **集合精简**: 13 个核心集合（vs 原方案 18+）
- **基础加密**: 仅对 OpenID 等关键字段加密，无需 KMS
- **简化索引**: 32 个核心索引（vs 原方案 50+）
- **单库方案**: 无需分片，使用单一数据库实例

---

## 二、核心集合设计（13 个集合）

### 2.1 用户域（2 个集合）

#### **users** - 用户主表

```javascript
{
  _id: ObjectId,
  openId: String,              // 微信OpenID（哈希存储）

  // 基础信息
  profile: {
    nickname: String,
    avatar: String,
    bio: String
  },

  // 等级积分
  level: Number,               // 用户等级 1-4
  points: Number,              // 当前积分
  experience: Number,          // 总经验值

  // 偏好设置（简化）
  preferences: {
    dietType: String,          // vegetarian/vegan/flexitarian
    notifications: Boolean,     // 是否接收通知（简化为布尔值）
    language: String           // zh-CN/en-US
  },

  // 快速访问统计（冗余设计）
  stats: {
    totalCarbonReduction: Number,
    totalMeals: Number,
    currentStreak: Number,
    gardenPlantsCount: Number
  },

  // 第三方同步状态（简化）
  syncedPlatforms: [String],   // ['meituan', 'eleme'] 已绑定的平台

  // 时间戳
  createdAt: Date,
  updatedAt: Date,
  lastLoginAt: Date
}

// 核心索引（3个）
db.users.createIndex({ openId: 1 }, { unique: true })
db.users.createIndex({ level: -1, points: -1 })  // 排行榜
db.users.createIndex({ lastLoginAt: -1 })  // 活跃度
```

#### **user_sessions** - 会话表（可选，用于多设备管理）

```javascript
{
  _id: ObjectId,
  userId: ObjectId,
  accessToken: String,
  expiresAt: Date,
  deviceInfo: String,          // 简化为字符串
  createdAt: Date
}

// 索引
db.user_sessions.createIndex({ userId: 1, expiresAt: 1 })
db.user_sessions.createIndex({ accessToken: 1 })
db.user_sessions.createIndex({ expiresAt: 1 }, { expireAfterSeconds: 0 })  // TTL自动清理
```

---

### 2.2 碳足迹域（2 个集合）

#### **meals** - 餐食记录表

```javascript
{
  _id: ObjectId,
  userId: ObjectId,

  // 基本信息
  mealType: String,            // breakfast/lunch/dinner/snack
  mealDate: Date,

  // 食材（简化结构）
  ingredients: [{
    ingredientId: ObjectId,    // 可选，关联ingredients表
    name: String,              // 必填
    quantity: Number,          // 克
    carbonFootprint: Number    // 单项碳排放
  }],

  // 烹饪信息（简化）
  cookingMethod: String,       // 可选

  // 碳足迹结果
  totalCarbonFootprint: Number,
  carbonReduction: Number,

  // 数据来源
  source: String,              // manual/third_party
  sourcePlatform: String,      // meituan/eleme等，仅第三方同步时填写
  sourceOrderId: String,       // 第三方订单ID（哈希存储）

  // 社交
  isPublic: Boolean,

  // 时间戳
  createdAt: Date
}

// 核心索引（4个）
db.meals.createIndex({ userId: 1, mealDate: -1 })  // 最高频查询
db.meals.createIndex({ userId: 1, createdAt: -1 })
db.meals.createIndex({ userId: 1, source: 1, sourceOrderId: 1 }, { unique: true, sparse: true })  // 防重复同步
db.meals.createIndex({ isPublic: 1, createdAt: -1 })  // 公开动态
```

#### **daily_stats** - 每日统计表（预聚合）

```javascript
{
  _id: ObjectId,
  userId: ObjectId,
  date: Date,                  // YYYY-MM-DD 00:00:00

  // 统计数据
  totalMeals: Number,
  totalCarbonReduction: Number,
  mealTypes: {
    breakfast: Number,
    lunch: Number,
    dinner: Number,
    snack: Number
  },

  // 时间戳
  createdAt: Date,
  updatedAt: Date
}

// 索引
db.daily_stats.createIndex({ userId: 1, date: -1 })
db.daily_stats.createIndex({ date: -1, totalCarbonReduction: -1 })  // 每日排行榜
db.daily_stats.createIndex({ userId: 1, date: 1 }, { unique: true })
```

---

### 2.3 花园域（1 个集合）

#### **gardens** - 花园表

```javascript
{
  _id: ObjectId,
  userId: ObjectId,            // 唯一

  // 场景
  currentScene: String,        // desert/rainforest/wetland/future
  unlockedScenes: [String],

  // 植物列表（简化）
  plants: [{
    id: String,                // 植物ID
    type: String,              // cactus/lavender/cherry/orchid
    position: { x: Number, y: Number },  // 2D坐标
    growth: Number,            // 0-100
    plantedAt: Date,
    isHarvested: Boolean
  }],

  // 统计（简化）
  totalPlantsPlanted: Number,
  totalPlantsHarvested: Number,

  // 时间戳
  createdAt: Date,
  updatedAt: Date
}

// 索引
db.gardens.createIndex({ userId: 1 }, { unique: true })
```

---

### 2.4 基础数据域（3 个集合）

#### **ingredients** - 食材库

```javascript
{
  _id: ObjectId,

  // 基本信息
  name: String,
  nameEn: String,
  category: String,            // vegetables/beans/grains/fruits

  // 碳足迹数据（简化）
  carbonFootprint: Number,     // 基础系数 kg CO2e/kg

  // 营养数据（简化，每100g）
  nutrition: {
    calories: Number,
    protein: Number,
    carbs: Number,
    fat: Number
  },

  // 第三方平台映射
  platformMappings: {
    meituan: String,           // 美团平台ID
    eleme: String              // 饿了么平台ID
  },

  // 状态
  status: String,              // active/deprecated
  createdAt: Date,
  updatedAt: Date
}

// 索引
db.ingredients.createIndex({ name: 1 })
db.ingredients.createIndex({ category: 1 })
db.ingredients.createIndex({ name: "text", nameEn: "text" })  // 全文搜索
```

#### **recipes** - 食谱库（可选）

```javascript
{
  _id: ObjectId,
  name: String,
  description: String,
  images: [String],

  // 食材
  ingredients: [{
    ingredientId: ObjectId,
    name: String,
    quantity: Number,
    unit: String
  }],

  // 预计算
  estimatedCarbonFootprint: Number,
  estimatedCalories: Number,

  // 来源
  source: String,              // official/user
  creatorId: ObjectId,

  // 互动
  usageCount: Number,

  createdAt: Date
}

// 索引
db.recipes.createIndex({ name: "text" })
db.recipes.createIndex({ usageCount: -1 })
```

#### **meat_products** - 肉类碳足迹数据库 🆕

```javascript
{
  _id: ObjectId,

  // 基本信息
  name: String,                // 中文名称，如"牛肉（牛腩）"
  nameEn: String,              // 英文名称，如"Beef Brisket"

  // 分类
  category: String,            // red_meat/poultry/seafood/processed_meat
  subcategory: String,         // beef/pork/lamb/chicken/fish等

  // 碳足迹数据（核心）
  carbonFootprint: Number,     // kg CO₂e/kg（基于权威研究）

  // 营养数据（每100g）
  nutrition: {
    calories: Number,          // 热量 kcal
    protein: Number,           // 蛋白质 g
    carbs: Number,             // 碳水化合物 g
    fat: Number                // 脂肪 g
  },

  // 生产信息
  productionMethod: String,    // conventional/organic/farmed/wild_caught/processed
  region: String,              // china_average/import

  // 数据来源（科学性保障）
  sources: [String],           // 如["FAO 2021", "Our World in Data"]

  // 对比分组
  comparisonGroup: String,     // 用于对比素食替代品，如"beef"/"pork"

  // 素食替代品推荐
  veganAlternatives: [String], // 推荐的素食替代品名称列表

  // 状态
  status: String,              // active/deprecated
  createdAt: Date,
  updatedAt: Date
}

// 索引（4个）
db.meat_products.createIndex({ name: 1 }, { unique: true })  // 查询肉类、确保唯一
db.meat_products.createIndex({ category: 1, subcategory: 1 }) // 分类统计
db.meat_products.createIndex({ carbonFootprint: -1 })         // 碳足迹排序
db.meat_products.createIndex({ status: 1 })                   // 过滤活跃数据
```

**设计说明**：

- **用途**: 用于"素食 vs 肉食"碳排放对比计算
- **数据规模**: 81 种肉类产品（红肉 20+禽肉 12+水产 27+加工肉 15+乳制品 7）
- **碳足迹范围**: 2.9-64.2 kg CO₂e/kg
- **数据来源**: FAO、Our World in Data（Poore & Nemecek 2018 Science）、IPCC 等权威研究
- **关键功能**:
  - 对比计算：素食 vs 肉食的减排量计算
  - 替代推荐：查询肉类的素食替代品
  - 教育展示：碳足迹排行榜
- **与 ingredients 关联**: veganAlternatives 字段关联 ingredients 集合中的素食食材

---

### 2.5 第三方同步域（2 个集合）

#### **sync_tasks** - 同步任务表

```javascript
{
  _id: ObjectId,
  userId: ObjectId,
  platform: String,            // meituan/eleme

  // 任务信息
  status: String,              // pending/completed/failed
  orderId: String,             // 第三方订单ID（哈希）
  mealId: ObjectId,            // 创建的餐食记录ID

  // 错误处理
  attempts: Number,
  errorMessage: String,
  nextRetry: Date,

  // 时间戳
  createdAt: Date,
  completedAt: Date
}

// 索引
db.sync_tasks.createIndex({ userId: 1, platform: 1, status: 1 })
db.sync_tasks.createIndex({ status: 1, nextRetry: 1 })
db.sync_tasks.createIndex({ platform: 1, orderId: 1 }, { unique: true, sparse: true })
db.sync_tasks.createIndex({ createdAt: 1 }, { expireAfterSeconds: 2592000 })  // 30天自动删除
```

#### **platform_configs** - 平台配置表

```javascript
{
  _id: ObjectId,
  platform: String,            // meituan/eleme

  // API配置
  apiEndpoint: String,
  apiVersion: String,
  authType: String,

  // 食材映射（简化）
  ingredientMappings: [{
    platformId: String,
    platformName: String,
    ourIngredientId: ObjectId
  }],

  status: String,
  updatedAt: Date
}

// 索引
db.platform_configs.createIndex({ platform: 1 }, { unique: true })
```

---

### 2.6 社交域（2 个集合）

#### **friends** - 好友关系表

```javascript
{
  _id: ObjectId,
  userId: ObjectId,
  friendId: ObjectId,
  status: String,              // pending/accepted/blocked

  // 简化的互动统计
  interactions: {
    waterGiven: Number,
    lastInteraction: Date
  },

  createdAt: Date
}

// 索引
db.friends.createIndex({ userId: 1, friendId: 1 }, { unique: true })
db.friends.createIndex({ userId: 1, status: 1 })
```

#### **posts** - 动态表（简化）

```javascript
{
  _id: ObjectId,
  userId: ObjectId,

  // 内容
  type: String,                // meal/garden/achievement
  content: String,
  images: [String],
  relatedMealId: ObjectId,

  // 互动
  likes: Number,

  // 可见性
  visibility: String,          // public/friends/private

  createdAt: Date
}

// 索引
db.posts.createIndex({ userId: 1, createdAt: -1 })
db.posts.createIndex({ visibility: 1, createdAt: -1 })
```

---

### 2.7 积分商城域（1 个集合）

#### **orders** - 订单表

```javascript
{
  _id: ObjectId,
  orderNo: String,
  userId: ObjectId,

  // 商品信息（简化，直接存储）
  productName: String,
  pointsPrice: Number,

  // 配送信息（基础存储）
  shippingInfo: {
    name: String,
    phone: String,
    address: String
  },

  // 状态
  status: String,              // pending/completed/cancelled

  createdAt: Date,
  completedAt: Date
}

// 索引
db.orders.createIndex({ orderNo: 1 }, { unique: true })
db.orders.createIndex({ userId: 1, createdAt: -1 })
```

---

## 三、简化的安全方案

### 3.1 基础加密策略

#### 加密字段（仅 3 类）

| 集合   | 字段               | 处理方式      | 说明             |
| ------ | ------------------ | ------------- | ---------------- |
| users  | openId             | SHA-256 哈希  | 不可逆，用于查询 |
| meals  | sourceOrderId      | SHA-256 哈希  | 防止订单 ID 泄露 |
| orders | shippingInfo.phone | 中间 4 位掩码 | 显示时脱敏       |

#### 加密工具（简化版）

```javascript
// cloudfunctions/common/encryption.js
const crypto = require("crypto");

class SimpleEncryption {
  constructor() {
    this.salt = process.env.ENCRYPTION_SALT || "my-garden-salt-2025";
  }

  // 哈希OpenID（不可逆）
  hashOpenId(openId) {
    return crypto
      .createHash("sha256")
      .update(openId + this.salt)
      .digest("hex");
  }

  // 哈希订单ID
  hashOrderId(orderId) {
    return crypto
      .createHash("sha256")
      .update(orderId + this.salt)
      .digest("hex");
  }

  // 手机号脱敏
  maskPhone(phone) {
    if (!phone || phone.length < 11) return phone;
    return phone.replace(/(\d{3})\d{4}(\d{4})/, "$1****$2");
  }

  // 地址脱敏
  maskAddress(address) {
    if (!address) return "";
    // 只保留到市级
    const parts = address.split("市");
    return parts[0] + "市***";
  }
}

module.exports = new SimpleEncryption();
```

### 3.2 基础访问控制

#### 云函数权限（简化）

```javascript
// cloudfunctions/common/permission.js
const cloud = require("wx-server-sdk");
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });
const db = cloud.database();

class PermissionChecker {
  // 检查用户是否有权访问特定数据
  async checkAccess(requestUserId, targetUserId, dataType) {
    // 1. 自己的数据
    if (requestUserId === targetUserId) {
      return { allowed: true, reason: "Owner access" };
    }

    // 2. 好友数据（仅花园和统计）
    if (dataType === "garden" || dataType === "stats") {
      const friendCount = await db
        .collection("friends")
        .where({
          userId: targetUserId,
          friendId: requestUserId,
          status: "accepted",
        })
        .count();

      if (friendCount.total > 0) {
        return { allowed: true, reason: "Friend access" };
      }
    }

    // 3. 公开数据
    if (dataType === "public_post") {
      return { allowed: true, reason: "Public access" };
    }

    return { allowed: false, reason: "Access denied" };
  }

  // 验证是否为自己的数据
  async checkOwnership(userId, collection, docId) {
    const doc = await db.collection(collection).doc(docId).get();
    if (!doc.data) {
      return { valid: false, reason: "Document not found" };
    }

    if (doc.data.userId !== userId) {
      return { valid: false, reason: "Not the owner" };
    }

    return { valid: true };
  }
}

module.exports = new PermissionChecker();
```

---

## 四、优化的索引策略

### 4.1 核心查询场景（3 个）

#### 场景 1: 用户首页加载（最高频）

```javascript
// 单次查询获取所有数据
async function loadUserDashboard(userId) {
  const db = cloud.database();

  // 并行查询
  const [user, garden, recentMeals, todayStats] = await Promise.all([
    // 1. 用户信息（主键查询）
    db.collection("users").doc(userId).get(),

    // 2. 花园（userId唯一索引）
    db.collection("gardens").where({ userId }).get(),

    // 3. 最近餐食（复合索引: userId + mealDate）
    db
      .collection("meals")
      .where({ userId })
      .orderBy("mealDate", "desc")
      .limit(5)
      .get(),

    // 4. 今日统计（复合索引: userId + date）
    db
      .collection("daily_stats")
      .where({
        userId,
        date: getTodayStart(),
      })
      .get(),
  ]);

  return {
    user: user.data,
    garden: garden.data[0],
    recentMeals: recentMeals.data,
    todayStats: todayStats.data[0],
  };
}

// 性能目标: 总计 < 50ms
```

#### 场景 2: 排行榜查询

```javascript
// 使用预聚合的daily_stats表
async function getDailyRanking(date, limit = 20) {
  const db = cloud.database();

  const rankings = await db
    .collection("daily_stats")
    .where({ date })
    .orderBy("totalCarbonReduction", "desc")
    .limit(limit)
    .get();

  // 获取用户信息
  const userIds = rankings.data.map((r) => r.userId);
  const users = await db
    .collection("users")
    .where({
      _id: db.command.in(userIds),
    })
    .field({
      profile: true,
      level: true,
    })
    .get();

  // 合并数据
  const usersMap = new Map(users.data.map((u) => [u._id, u]));
  return rankings.data.map((rank, index) => ({
    rank: index + 1,
    user: usersMap.get(rank.userId),
    carbonReduction: rank.totalCarbonReduction,
    mealCount: rank.totalMeals,
  }));
}

// 性能目标: < 100ms
```

#### 场景 3: 第三方同步防重

```javascript
// 唯一复合索引
async function checkOrderSynced(userId, platform, orderId) {
  const db = cloud.database();
  const encryption = require("./common/encryption");

  const hashedOrderId = encryption.hashOrderId(orderId);

  const existing = await db
    .collection("meals")
    .where({
      userId,
      source: "third_party",
      sourceOrderId: hashedOrderId,
    })
    .get();

  return existing.data.length > 0;
}

// 性能目标: < 20ms
```

### 4.2 索引清单

| 集合             | 索引                          | 类型     | 用途          |
| ---------------- | ----------------------------- | -------- | ------------- |
| users            | openId                        | 唯一     | 登录查询      |
| users            | level, points                 | 复合降序 | 排行榜        |
| users            | lastLoginAt                   | 降序     | 活跃度统计    |
| user_sessions    | userId, expiresAt             | 复合     | 会话管理      |
| user_sessions    | accessToken                   | 普通     | Token 验证    |
| user_sessions    | expiresAt                     | TTL      | 自动清理      |
| meals            | userId, mealDate              | 复合降序 | 个人记录查询  |
| meals            | userId, createdAt             | 复合降序 | 最近记录      |
| meals            | userId, source, sourceOrderId | 唯一稀疏 | 防重复同步    |
| meals            | isPublic, createdAt           | 复合降序 | 公开动态      |
| daily_stats      | userId, date                  | 复合降序 | 个人统计      |
| daily_stats      | date, totalCarbonReduction    | 复合降序 | 排行榜        |
| daily_stats      | userId, date                  | 唯一     | 数据唯一性    |
| gardens          | userId                        | 唯一     | 个人花园      |
| ingredients      | name                          | 普通     | 名称查询      |
| ingredients      | category                      | 普通     | 分类查询      |
| ingredients      | name, nameEn                  | 文本     | 全文搜索      |
| recipes          | name                          | 文本     | 全文搜索      |
| recipes          | usageCount                    | 降序     | 热门食谱      |
| sync_tasks       | userId, platform, status      | 复合     | 任务管理      |
| sync_tasks       | status, nextRetry             | 复合     | 重试队列      |
| sync_tasks       | platform, orderId             | 唯一稀疏 | 任务唯一性    |
| sync_tasks       | createdAt                     | TTL      | 30 天自动删除 |
| platform_configs | platform                      | 唯一     | 平台配置      |
| friends          | userId, friendId              | 唯一     | 好友关系      |
| friends          | userId, status                | 复合     | 好友列表      |
| posts            | userId, createdAt             | 复合降序 | 个人动态      |
| posts            | visibility, createdAt         | 复合降序 | 公开动态      |
| orders           | orderNo                       | 唯一     | 订单查询      |
| orders           | userId, createdAt             | 复合降序 | 订单列表      |
| meat_products    | name                          | 唯一     | 肉类名称查询  |
| meat_products    | category, subcategory         | 复合     | 分类统计      |
| meat_products    | carbonFootprint               | 降序     | 碳足迹排序    |
| meat_products    | status                        | 普通     | 过滤活跃数据  |

**总计: 32 个索引**

---

## 五、第三方数据同步

### 5.1 同步流程架构

```
用户授权 → 平台OAuth → 订单同步 → 食材映射 → 碳足迹计算 → 创建餐食记录
   ↓           ↓           ↓           ↓            ↓             ↓
 绑定平台   获取Token   防重检查   智能匹配   自动计算      更新统计
```

### 5.2 美团订单同步实现

```javascript
// cloudfunctions/sync/meituan-sync/index.js
const cloud = require("wx-server-sdk");
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });
const db = cloud.database();
const _ = db.command;
const encryption = require("../../common/encryption");

/**
 * 美团订单同步云函数
 */
exports.main = async (event) => {
  const { userId, orderId, accessToken } = event;

  try {
    // 1. 哈希订单ID
    const hashedOrderId = encryption.hashOrderId(orderId);

    // 2. 检查是否已同步
    const existingMeal = await db
      .collection("meals")
      .where({
        userId,
        source: "third_party",
        sourcePlatform: "meituan",
        sourceOrderId: hashedOrderId,
      })
      .get();

    if (existingMeal.data.length > 0) {
      return {
        code: 0,
        message: "Already synced",
        mealId: existingMeal.data[0]._id,
      };
    }

    // 3. 调用美团API获取订单详情
    const orderData = await fetchMeituanOrder(orderId, accessToken);

    if (!orderData) {
      throw new Error("Failed to fetch order from Meituan");
    }

    // 4. 食材映射
    const ingredients = await mapMeituanIngredients(orderData.dishes);

    // 5. 计算碳足迹
    const totalCarbon = ingredients.reduce(
      (sum, item) => sum + (item.carbonFootprint || 0),
      0
    );
    const carbonReduction = Math.max(0, 2.5 - totalCarbon); // 基准2.5kg

    // 6. 判断餐类型
    const mealType = determineMealType(orderData.orderTime);

    // 7. 创建餐食记录
    const mealResult = await db.collection("meals").add({
      data: {
        userId,
        mealType,
        mealDate: new Date(orderData.orderTime),
        ingredients,
        totalCarbonFootprint: totalCarbon,
        carbonReduction,
        source: "third_party",
        sourcePlatform: "meituan",
        sourceOrderId: hashedOrderId,
        isPublic: false,
        createdAt: new Date(),
      },
    });

    // 8. 更新用户统计
    await db
      .collection("users")
      .where({ _id: userId })
      .update({
        data: {
          "stats.totalMeals": _.inc(1),
          "stats.totalCarbonReduction": _.inc(carbonReduction),
          updatedAt: new Date(),
        },
      });

    // 9. 更新每日统计
    await updateDailyStats(userId, new Date(orderData.orderTime), {
      meals: 1,
      carbonReduction,
      mealType,
    });

    // 10. 记录同步任务
    await db.collection("sync_tasks").add({
      data: {
        userId,
        platform: "meituan",
        status: "completed",
        orderId: hashedOrderId,
        mealId: mealResult._id,
        attempts: 1,
        createdAt: new Date(),
        completedAt: new Date(),
      },
    });

    return {
      code: 0,
      message: "Sync completed successfully",
      data: {
        mealId: mealResult._id,
        carbonReduction,
        pointsEarned: Math.floor(carbonReduction * 10),
      },
    };
  } catch (error) {
    console.error("Meituan sync failed:", error);

    // 记录失败任务
    await db.collection("sync_tasks").add({
      data: {
        userId,
        platform: "meituan",
        status: "failed",
        orderId: encryption.hashOrderId(orderId),
        attempts: 1,
        errorMessage: error.message,
        nextRetry: new Date(Date.now() + 300000), // 5分钟后重试
        createdAt: new Date(),
      },
    });

    return {
      code: 500,
      message: "Sync failed",
      error: error.message,
    };
  }
};

/**
 * 调用美团API获取订单详情
 */
async function fetchMeituanOrder(orderId, accessToken) {
  // 这里应该调用实际的美团API
  // 示例代码
  const axios = require("axios");

  try {
    const response = await axios.get(
      "https://api.meituan.com/orders/" + orderId,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
        timeout: 5000,
      }
    );

    return response.data;
  } catch (error) {
    console.error("Failed to fetch Meituan order:", error);
    return null;
  }
}

/**
 * 映射美团食材到我们的食材库
 */
async function mapMeituanIngredients(dishes) {
  const mapped = [];

  // 获取平台配置
  const config = await db
    .collection("platform_configs")
    .where({ platform: "meituan" })
    .get();

  const mappings = config.data[0]?.ingredientMappings || [];
  const mappingsMap = new Map(
    mappings.map((m) => [m.platformId, m.ourIngredientId])
  );

  for (const dish of dishes) {
    // 尝试从映射表查找
    const ourIngredientId = mappingsMap.get(dish.dishId);

    if (ourIngredientId) {
      // 找到映射，获取我们的食材详情
      const ingredient = await db
        .collection("ingredients")
        .doc(ourIngredientId)
        .get();

      if (ingredient.data) {
        mapped.push({
          ingredientId: ingredient.data._id,
          name: ingredient.data.name,
          quantity: dish.quantity || 100,
          carbonFootprint:
            ingredient.data.carbonFootprint * (dish.quantity / 1000),
        });
        continue;
      }
    }

    // 没有映射，尝试模糊匹配
    const fuzzyMatch = await db
      .collection("ingredients")
      .where({
        name: db.RegExp({
          regexp: dish.dishName,
          options: "i",
        }),
      })
      .limit(1)
      .get();

    if (fuzzyMatch.data.length > 0) {
      const ingredient = fuzzyMatch.data[0];

      // 创建新映射
      await db
        .collection("platform_configs")
        .where({ platform: "meituan" })
        .update({
          data: {
            ingredientMappings: _.push({
              platformId: dish.dishId,
              platformName: dish.dishName,
              ourIngredientId: ingredient._id,
            }),
          },
        });

      mapped.push({
        ingredientId: ingredient._id,
        name: ingredient.name,
        quantity: dish.quantity || 100,
        carbonFootprint: ingredient.carbonFootprint * (dish.quantity / 1000),
      });
    } else {
      // 完全无法匹配，使用默认估算
      mapped.push({
        name: dish.dishName,
        quantity: dish.quantity || 100,
        carbonFootprint: 0.5, // 默认估算值
      });
    }
  }

  return mapped;
}

/**
 * 根据订单时间判断餐类型
 */
function determineMealType(orderTime) {
  const hour = new Date(orderTime).getHours();

  if (hour >= 6 && hour < 10) return "breakfast";
  if (hour >= 10 && hour < 14) return "lunch";
  if (hour >= 14 && hour < 17) return "snack";
  if (hour >= 17 && hour < 22) return "dinner";
  return "snack";
}

/**
 * 更新每日统计
 */
async function updateDailyStats(userId, date, updates) {
  const dayStart = new Date(date);
  dayStart.setHours(0, 0, 0, 0);

  // 查询今日统计是否存在
  const existing = await db
    .collection("daily_stats")
    .where({
      userId,
      date: dayStart,
    })
    .get();

  if (existing.data.length > 0) {
    // 更新现有统计
    const stats = existing.data[0];
    await db
      .collection("daily_stats")
      .doc(stats._id)
      .update({
        data: {
          totalMeals: _.inc(updates.meals),
          totalCarbonReduction: _.inc(updates.carbonReduction),
          [`mealTypes.${updates.mealType}`]: _.inc(1),
          updatedAt: new Date(),
        },
      });
  } else {
    // 创建新统计
    await db.collection("daily_stats").add({
      data: {
        userId,
        date: dayStart,
        totalMeals: updates.meals,
        totalCarbonReduction: updates.carbonReduction,
        mealTypes: {
          breakfast: updates.mealType === "breakfast" ? 1 : 0,
          lunch: updates.mealType === "lunch" ? 1 : 0,
          dinner: updates.mealType === "dinner" ? 1 : 0,
          snack: updates.mealType === "snack" ? 1 : 0,
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    });
  }
}
```

### 5.3 饿了么订单同步（类似结构）

```javascript
// cloudfunctions/sync/eleme-sync/index.js
// 结构与美团类似，只是API调用和映射逻辑不同

exports.main = async (event) => {
  // 类似美团的实现，但调用饿了么API
  // ...
};
```

---

## 六、数据库初始化脚本

### 6.1 创建所有集合和索引

```javascript
// cloudfunctions/database/init-collections.js
const cloud = require("wx-server-sdk");
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });
const db = cloud.database();

/**
 * 初始化所有数据库集合和索引
 */
exports.main = async (event) => {
  const results = [];

  try {
    // 1. 创建users集合
    await createUsersCollection();
    results.push({ collection: "users", status: "success" });

    // 2. 创建user_sessions集合
    await createUserSessionsCollection();
    results.push({ collection: "user_sessions", status: "success" });

    // 3. 创建meals集合
    await createMealsCollection();
    results.push({ collection: "meals", status: "success" });

    // 4. 创建daily_stats集合
    await createDailyStatsCollection();
    results.push({ collection: "daily_stats", status: "success" });

    // 5. 创建gardens集合
    await createGardensCollection();
    results.push({ collection: "gardens", status: "success" });

    // 6. 创建ingredients集合
    await createIngredientsCollection();
    results.push({ collection: "ingredients", status: "success" });

    // 7. 创建recipes集合
    await createRecipesCollection();
    results.push({ collection: "recipes", status: "success" });

    // 8. 创建sync_tasks集合
    await createSyncTasksCollection();
    results.push({ collection: "sync_tasks", status: "success" });

    // 9. 创建platform_configs集合
    await createPlatformConfigsCollection();
    results.push({ collection: "platform_configs", status: "success" });

    // 10. 创建friends集合
    await createFriendsCollection();
    results.push({ collection: "friends", status: "success" });

    // 11. 创建posts集合
    await createPostsCollection();
    results.push({ collection: "posts", status: "success" });

    // 12. 创建orders集合
    await createOrdersCollection();
    results.push({ collection: "orders", status: "success" });

    // 13. 创建meat_products集合
    await createMeatProductsCollection();
    results.push({ collection: "meat_products", status: "success" });

    return {
      code: 0,
      message: "Database initialization completed (13 collections)",
      results,
    };
  } catch (error) {
    console.error("Database initialization failed:", error);
    return {
      code: 500,
      message: "Initialization failed",
      error: error.message,
      results,
    };
  }
};

// 创建users集合和索引
async function createUsersCollection() {
  try {
    await db.createCollection("users");
  } catch (e) {
    console.log("users collection may already exist");
  }

  // 创建索引
  await db.collection("users").createIndex({
    keys: { openId: 1 },
    unique: true,
    name: "openId_unique",
  });

  await db.collection("users").createIndex({
    keys: { level: -1, points: -1 },
    name: "level_points_ranking",
  });

  await db.collection("users").createIndex({
    keys: { lastLoginAt: -1 },
    name: "lastLoginAt_index",
  });
}

// 创建user_sessions集合和索引
async function createUserSessionsCollection() {
  try {
    await db.createCollection("user_sessions");
  } catch (e) {
    console.log("user_sessions collection may already exist");
  }

  await db.collection("user_sessions").createIndex({
    keys: { userId: 1, expiresAt: 1 },
    name: "userId_expiresAt_index",
  });

  await db.collection("user_sessions").createIndex({
    keys: { accessToken: 1 },
    name: "accessToken_index",
  });

  await db.collection("user_sessions").createIndex({
    keys: { expiresAt: 1 },
    expireAfterSeconds: 0,
    name: "expiresAt_ttl",
  });
}

// 创建meals集合和索引
async function createMealsCollection() {
  try {
    await db.createCollection("meals");
  } catch (e) {
    console.log("meals collection may already exist");
  }

  await db.collection("meals").createIndex({
    keys: { userId: 1, mealDate: -1 },
    name: "userId_mealDate_index",
  });

  await db.collection("meals").createIndex({
    keys: { userId: 1, createdAt: -1 },
    name: "userId_createdAt_index",
  });

  await db.collection("meals").createIndex({
    keys: { userId: 1, source: 1, sourceOrderId: 1 },
    unique: true,
    sparse: true,
    name: "userId_source_orderId_unique",
  });

  await db.collection("meals").createIndex({
    keys: { isPublic: 1, createdAt: -1 },
    name: "isPublic_createdAt_index",
  });
}

// 创建daily_stats集合和索引
async function createDailyStatsCollection() {
  try {
    await db.createCollection("daily_stats");
  } catch (e) {
    console.log("daily_stats collection may already exist");
  }

  await db.collection("daily_stats").createIndex({
    keys: { userId: 1, date: -1 },
    name: "userId_date_index",
  });

  await db.collection("daily_stats").createIndex({
    keys: { date: -1, totalCarbonReduction: -1 },
    name: "date_carbonReduction_ranking",
  });

  await db.collection("daily_stats").createIndex({
    keys: { userId: 1, date: 1 },
    unique: true,
    name: "userId_date_unique",
  });
}

// 创建gardens集合和索引
async function createGardensCollection() {
  try {
    await db.createCollection("gardens");
  } catch (e) {
    console.log("gardens collection may already exist");
  }

  await db.collection("gardens").createIndex({
    keys: { userId: 1 },
    unique: true,
    name: "userId_unique",
  });
}

// 创建ingredients集合和索引
async function createIngredientsCollection() {
  try {
    await db.createCollection("ingredients");
  } catch (e) {
    console.log("ingredients collection may already exist");
  }

  await db.collection("ingredients").createIndex({
    keys: { name: 1 },
    name: "name_index",
  });

  await db.collection("ingredients").createIndex({
    keys: { category: 1 },
    name: "category_index",
  });

  // 全文搜索索引
  await db.collection("ingredients").createIndex({
    keys: { name: "text", nameEn: "text" },
    name: "name_fulltext",
    weights: { name: 10, nameEn: 5 },
    default_language: "chinese",
  });
}

// 创建recipes集合和索引
async function createRecipesCollection() {
  try {
    await db.createCollection("recipes");
  } catch (e) {
    console.log("recipes collection may already exist");
  }

  await db.collection("recipes").createIndex({
    keys: { name: "text" },
    name: "name_fulltext",
  });

  await db.collection("recipes").createIndex({
    keys: { usageCount: -1 },
    name: "usageCount_index",
  });
}

// 创建sync_tasks集合和索引
async function createSyncTasksCollection() {
  try {
    await db.createCollection("sync_tasks");
  } catch (e) {
    console.log("sync_tasks collection may already exist");
  }

  await db.collection("sync_tasks").createIndex({
    keys: { userId: 1, platform: 1, status: 1 },
    name: "userId_platform_status_index",
  });

  await db.collection("sync_tasks").createIndex({
    keys: { status: 1, nextRetry: 1 },
    name: "status_nextRetry_index",
  });

  await db.collection("sync_tasks").createIndex({
    keys: { platform: 1, orderId: 1 },
    unique: true,
    sparse: true,
    name: "platform_orderId_unique",
  });

  await db.collection("sync_tasks").createIndex({
    keys: { createdAt: 1 },
    expireAfterSeconds: 2592000, // 30天
    name: "createdAt_ttl",
  });
}

// 创建platform_configs集合和索引
async function createPlatformConfigsCollection() {
  try {
    await db.createCollection("platform_configs");
  } catch (e) {
    console.log("platform_configs collection may already exist");
  }

  await db.collection("platform_configs").createIndex({
    keys: { platform: 1 },
    unique: true,
    name: "platform_unique",
  });
}

// 创建friends集合和索引
async function createFriendsCollection() {
  try {
    await db.createCollection("friends");
  } catch (e) {
    console.log("friends collection may already exist");
  }

  await db.collection("friends").createIndex({
    keys: { userId: 1, friendId: 1 },
    unique: true,
    name: "userId_friendId_unique",
  });

  await db.collection("friends").createIndex({
    keys: { userId: 1, status: 1 },
    name: "userId_status_index",
  });
}

// 创建posts集合和索引
async function createPostsCollection() {
  try {
    await db.createCollection("posts");
  } catch (e) {
    console.log("posts collection may already exist");
  }

  await db.collection("posts").createIndex({
    keys: { userId: 1, createdAt: -1 },
    name: "userId_createdAt_index",
  });

  await db.collection("posts").createIndex({
    keys: { visibility: 1, createdAt: -1 },
    name: "visibility_createdAt_index",
  });
}

// 创建orders集合和索引
async function createOrdersCollection() {
  try {
    await db.createCollection("orders");
  } catch (e) {
    console.log("orders collection may already exist");
  }

  await db.collection("orders").createIndex({
    keys: { orderNo: 1 },
    unique: true,
    name: "orderNo_unique",
  });

  await db.collection("orders").createIndex({
    keys: { userId: 1, createdAt: -1 },
    name: "userId_createdAt_index",
  });
}

// 创建meat_products集合和索引
async function createMeatProductsCollection() {
  try {
    await db.createCollection("meat_products");
  } catch (e) {
    console.log("meat_products collection may already exist");
  }

  await db.collection("meat_products").createIndex({
    keys: { name: 1 },
    unique: true,
    name: "name_unique",
  });

  await db.collection("meat_products").createIndex({
    keys: { category: 1, subcategory: 1 },
    name: "category_subcategory_index",
  });

  await db.collection("meat_products").createIndex({
    keys: { carbonFootprint: -1 },
    name: "carbonFootprint_index",
  });

  await db.collection("meat_products").createIndex({
    keys: { status: 1 },
    name: "status_index",
  });
}
```

---

## 七、数据备份与恢复

### 7.1 每日备份云函数

```javascript
// cloudfunctions/maintenance/backup/index.js
const cloud = require("wx-server-sdk");
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });
const db = cloud.database();

/**
 * 每日备份云函数（定时触发：每天凌晨2点）
 */
exports.main = async (event) => {
  const collections = ["users", "meals", "gardens", "daily_stats"];
  const backupResults = [];

  for (const collName of collections) {
    try {
      console.log(`Starting backup for ${collName}...`);

      // 分批导出数据（每次1000条）
      let allData = [];
      let skip = 0;
      const batchSize = 1000;

      while (true) {
        const batch = await db
          .collection(collName)
          .skip(skip)
          .limit(batchSize)
          .get();

        if (batch.data.length === 0) break;

        allData = allData.concat(batch.data);
        skip += batchSize;

        if (batch.data.length < batchSize) break;
      }

      // 上传到云存储
      const timestamp = Date.now();
      const fileName = `backup/${collName}_${timestamp}.json`;

      await cloud.uploadFile({
        cloudPath: fileName,
        fileContent: Buffer.from(JSON.stringify(allData, null, 2)),
      });

      backupResults.push({
        collection: collName,
        recordCount: allData.length,
        fileName: fileName,
        status: "success",
      });

      console.log(
        `Backup completed for ${collName}: ${allData.length} records`
      );
    } catch (error) {
      console.error(`Backup failed for ${collName}:`, error);
      backupResults.push({
        collection: collName,
        status: "failed",
        error: error.message,
      });
    }
  }

  // 记录备份日志
  await db.collection("backup_logs").add({
    data: {
      backupTime: new Date(),
      results: backupResults,
      success: backupResults.every((r) => r.status === "success"),
    },
  });

  return {
    code: 0,
    message: "Backup completed",
    results: backupResults,
  };
};
```

---

## 八、性能监控

### 8.1 慢查询监控

```javascript
// cloudfunctions/maintenance/monitor/index.js
const cloud = require("wx-server-sdk");
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

/**
 * 性能监控云函数
 * 在其他云函数中调用此函数记录慢查询
 */
exports.logSlowQuery = async (collection, query, duration) => {
  if (duration > 200) {
    // 超过200ms记录
    console.warn(`Slow query detected: ${collection}, duration: ${duration}ms`);

    // 可以将慢查询记录到专门的集合或日志服务
    // 这里简化为控制台输出
  }
};

/**
 * 数据库容量检查（每周执行）
 */
exports.checkCapacity = async (event) => {
  const db = cloud.database();
  const collections = [
    "users",
    "meals",
    "gardens",
    "daily_stats",
    "ingredients",
    "meat_products",
  ];

  const report = [];

  for (const collName of collections) {
    const count = await db.collection(collName).count();
    report.push({
      collection: collName,
      documentCount: count.total,
      estimatedSize: estimateSize(collName, count.total),
    });
  }

  const totalSize = report.reduce((sum, item) => sum + item.estimatedSize, 0);

  return {
    code: 0,
    report,
    totalSize: formatBytes(totalSize),
    needsAction: totalSize > 80 * 1024 * 1024 * 1024, // 超过80GB
  };
};

// 估算集合大小
function estimateSize(collection, count) {
  const avgSizes = {
    users: 3 * 1024, // 3KB
    meals: 1.5 * 1024, // 1.5KB
    gardens: 2 * 1024, // 2KB
    daily_stats: 0.5 * 1024, // 0.5KB
    ingredients: 3 * 1024, // 3KB
    meat_products: 2 * 1024, // 2KB
  };

  return (avgSizes[collection] || 1024) * count;
}

// 格式化字节
function formatBytes(bytes) {
  if (bytes < 1024) return bytes + " B";
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + " KB";
  if (bytes < 1024 * 1024 * 1024)
    return (bytes / 1024 / 1024).toFixed(2) + " MB";
  return (bytes / 1024 / 1024 / 1024).toFixed(2) + " GB";
}
```

---

## 九、容量规划（10 万用户）

### 9.1 存储容量估算

| 集合             | 单条大小 | 条数估算   | 总容量    |
| ---------------- | -------- | ---------- | --------- |
| users            | 3KB      | 100,000    | 300MB     |
| user_sessions    | 0.5KB    | 200,000    | 100MB     |
| meals            | 1.5KB    | 36,000,000 | 54GB      |
| daily_stats      | 0.5KB    | 36,500,000 | 18GB      |
| gardens          | 2KB      | 100,000    | 200MB     |
| ingredients      | 3KB      | 5,000      | 15MB      |
| recipes          | 5KB      | 10,000     | 50MB      |
| sync_tasks       | 0.5KB    | 1,000,000  | 500MB     |
| platform_configs | 10KB     | 10         | 100KB     |
| friends          | 0.2KB    | 3,000,000  | 600MB     |
| posts            | 2KB      | 3,000,000  | 6GB       |
| orders           | 1KB      | 500,000    | 500MB     |
| meat_products    | 2KB      | 81         | 162KB     |
| **总计**         | -        | -          | **≈80GB** |

**建议配置**: 100GB 存储空间（预留 20%增长）

### 9.2 性能估算

#### 日活 1-3 万用户场景

- **每日查询量**: 约 1000 万次（每用户平均 300-400 次请求）
- **每日写入量**: 约 100 万次（餐食记录、统计更新等）
- **峰值 QPS**: 约 200-500（晚餐时段）

#### 数据库性能要求

- **单次查询响应**: <50ms（95%ile）
- **复杂聚合查询**: <200ms（95%ile）
- **并发连接数**: 100-200
- **数据库实例**: 2 核 4GB 即可满足

### 9.3 成本估算（腾讯云开发）

#### 月度成本明细

| 项目         | 用量         | 单价             | 月费用    |
| ------------ | ------------ | ---------------- | --------- |
| **数据库**   |
| 存储容量     | 100GB        | ¥0.07/GB/天      | ¥210      |
| 读操作       | 1000 万次/天 | ¥0.015/万次      | ¥45       |
| 写操作       | 100 万次/天  | ¥0.05/万次       | ¥150      |
| **云存储**   |
| 存储容量     | 50GB         | ¥0.0043/GB/天    | ¥6.5      |
| CDN 流量     | 100GB        | ¥0.18/GB         | ¥18       |
| **云函数**   |
| 调用次数     | 5000 万次    | ¥0.0133/万次     | ¥66.5     |
| 资源使用     | 10 万 GB·s   | ¥0.00011639/GB·s | ¥11.6     |
| **其他**     |
| 备份存储     | 20GB         | ¥0.0043/GB/天    | ¥2.6      |
| **月度总计** | -            | -                | **≈¥510** |

**年度成本**: 约 **¥6,120**

---

## 十、实施步骤

### 第一阶段：核心功能（1 周）

#### Day 1-2: 数据库初始化

- [ ] 创建 13 个核心集合
- [ ] 配置 32 个索引
- [ ] 测试索引性能

#### Day 3-4: 基础工具

- [ ] 实现加密工具（SHA-256）
- [ ] 实现权限检查中间件
- [ ] 编写单元测试

#### Day 5-7: 核心云函数

- [ ] 更新 login 云函数（支持哈希 OpenID）
- [ ] 更新 user 云函数
- [ ] 更新 garden 云函数
- [ ] 更新 carbon 云函数

### 第二阶段：第三方同步（1 周）

#### Day 1-3: 美团同步

- [ ] 创建 sync_tasks 集合
- [ ] 创建 platform_configs 集合
- [ ] 实现美团订单同步云函数
- [ ] 配置食材映射表
- [ ] 测试同步流程

#### Day 4-6: 饿了么同步

- [ ] 实现饿了么订单同步云函数
- [ ] 配置饿了么食材映射
- [ ] 测试同步流程

#### Day 7: 同步任务管理

- [ ] 实现失败重试机制
- [ ] 配置定时清理任务
- [ ] 监控告警配置

### 第三阶段：社交和商城（3 天）

#### Day 1: 社交功能

- [ ] 创建 friends 集合
- [ ] 创建 posts 集合
- [ ] 实现好友添加功能
- [ ] 实现动态发布功能

#### Day 2: 积分商城

- [ ] 创建 orders 集合
- [ ] 实现订单创建
- [ ] 实现积分兑换

#### Day 3: 测试和优化

- [ ] 功能测试
- [ ] 性能测试
- [ ] Bug 修复

### 第四阶段：优化和上线（3 天）

#### Day 1: 性能优化

- [ ] 慢查询优化
- [ ] 索引调优
- [ ] 缓存策略

#### Day 2: 运维配置

- [ ] 配置每日备份
- [ ] 配置容量监控
- [ ] 配置告警规则

#### Day 3: 上线准备

- [ ] 数据迁移测试
- [ ] 压力测试
- [ ] 灰度发布

---

## 十一、关键差异对比

| 项目             | 完整版方案           | 简化版方案（当前）       |
| ---------------- | -------------------- | ------------------------ |
| **用户规模**     | 10-100 万            | 10 万以内                |
| **集合数量**     | 18+                  | 13                       |
| **索引数量**     | 50+                  | 32                       |
| **加密方案**     | 腾讯云 KMS + AES-256 | Node.js crypto + SHA-256 |
| **敏感数据字段** | 9 类                 | 3 类                     |
| **审计日志**     | 完整审计系统         | 基础日志                 |
| **权限控制**     | 行级+列级            | 基础三级                 |
| **分片策略**     | 冷热分离+分区        | 单库                     |
| **备份方案**     | 实时+定期+归档       | 每日备份                 |
| **监控系统**     | 完整监控+告警        | 基础监控                 |
| **月度成本**     | ¥7,176               | ¥510                     |
| **实施周期**     | 8 周                 | 2.5 周                   |
| **开发复杂度**   | 高                   | 中                       |
| **运维复杂度**   | 高                   | 低                       |

---

## 十二、迁移指南

### 12.1 从现有数据库迁移

如果您已有 users、meals、gardens 等基础集合，可以按以下步骤迁移：

#### Step 1: 备份现有数据

```bash
# 使用云开发CLI导出数据
tcb database:export users -e your-env-id
tcb database:export meals -e your-env-id
tcb database:export gardens -e your-env-id
```

#### Step 2: 添加新字段

```javascript
// 为users集合添加新字段
db.collection("users")
  .where({})
  .update({
    data: {
      "stats.totalCarbonReduction": 0,
      "stats.totalMeals": 0,
      "stats.currentStreak": 0,
      "stats.gardenPlantsCount": 0,
      syncedPlatforms: [],
    },
  });

// 为meals集合添加新字段
db.collection("meals")
  .where({})
  .update({
    data: {
      source: "manual",
      isPublic: false,
    },
  });
```

#### Step 3: 创建新集合

```javascript
// 执行初始化脚本创建新集合
// daily_stats, sync_tasks, platform_configs, friends, posts, orders
```

#### Step 4: 迁移历史数据到 daily_stats

```javascript
// 聚合历史餐食数据到daily_stats
// 可通过云函数批量执行
```

### 12.2 数据一致性检查

```javascript
// 检查数据完整性
async function checkDataIntegrity() {
  const db = cloud.database();

  // 1. 检查users和gardens的一致性
  const usersCount = await db.collection("users").count();
  const gardensCount = await db.collection("gardens").count();

  console.log(`Users: ${usersCount.total}, Gardens: ${gardensCount.total}`);

  // 2. 检查meals和daily_stats的一致性
  // ...

  // 3. 检查索引是否正常
  // ...
}
```

---

## 十三、常见问题（FAQ）

### Q1: 为什么不使用腾讯云 KMS？

**A**: 对于 10 万用户规模，Node.js 内置 crypto 的 SHA-256 哈希已足够安全，且：

- 无需额外的 KMS 费用（约 ¥200/月）
- 简化开发和部署流程
- 性能更好（本地计算）

### Q2: 如何保证第三方同步的数据安全？

**A**:

- 订单 ID 使用 SHA-256 哈希存储
- API Token 加密存储
- HTTPS 传输
- 定期清理过期的同步任务（30 天）

### Q3: 如果用户超过 10 万怎么办？

**A**: 可以升级到完整版方案：

- 启用冷热数据分离
- 配置数据分片
- 升级到腾讯云 KMS
- 增加审计日志系统

### Q4: daily_stats 表如何保证数据一致性？

**A**:

- 使用唯一复合索引（userId + date）防止重复
- 使用原子性更新操作（`_.inc()`）
- 定期校验和修复不一致数据

### Q5: 备份数据存储在哪里？

**A**:

- 存储在腾讯云存储（Cloud Storage）
- 路径：`backup/集合名_时间戳.json`
- 建议保留最近 7 天的备份
- 可配置自动上传到对象存储 OSS

---

## 十四、后续优化建议

### 短期优化（1-3 个月）

1. **食材库扩充**: 从当前 5000 种扩展到 1 万种
2. **食材映射优化**: 提高美团/饿了么食材匹配准确率到 95%
3. **查询缓存**: 对热点数据（排行榜、热门食谱）增加缓存层
4. **图片优化**: 使用腾讯云 COS+CDN 加速图片加载

### 中期优化（3-6 个月）

1. **推荐系统**: 基于用户历史数据推荐食谱
2. **AI 识别**: 集成食物图片识别功能
3. **数据分析**: 提供更详细的碳足迹分析报告
4. **社交功能增强**: 添加评论、点赞、分享等功能

### 长期优化（6-12 个月）

1. **多平台支持**: 接入更多外卖平台（京东到家、盒马等）
2. **企业版功能**: 支持企业团队碳减排管理
3. **数据导出**: 支持个人碳足迹报告导出
4. **国际化**: 支持英文、日文等多语言

---

## 附录 A：文件清单

### 云函数目录结构

```
cloudfunctions/
├── common/
│   ├── encryption.js           # 加密工具（200行）
│   └── permission.js           # 权限检查（150行）
│
├── database/
│   └── init-collections.js     # 数据库初始化（500行）
│
├── sync/
│   ├── meituan-sync/
│   │   ├── index.js           # 美团同步（300行）
│   │   └── package.json
│   └── eleme-sync/
│       ├── index.js           # 饿了么同步（300行）
│       └── package.json
│
├── maintenance/
│   ├── backup/
│   │   ├── index.js           # 备份（150行）
│   │   └── package.json
│   └── monitor/
│       ├── index.js           # 监控（100行）
│       └── package.json
│
└── [现有云函数]
    ├── login/
    ├── user/
    ├── garden/
    └── carbon/
```

**总计新增代码**: 约 1700 行

---

## 附录 B：环境变量配置

```bash
# .env 文件配置

# 腾讯云开发
CLOUDBASE_ENVID=your-env-id
CLOUDBASE_REGION=ap-shanghai

# 微信小程序
WECHAT_APPID=your-wechat-appid
WECHAT_SECRET=your-wechat-secret

# 加密盐值
ENCRYPTION_SALT=my-garden-salt-2025-change-this

# 美团API配置
MEITUAN_API_ENDPOINT=https://api.meituan.com
MEITUAN_API_KEY=your-meituan-api-key
MEITUAN_API_SECRET=your-meituan-api-secret

# 饿了么API配置
ELEME_API_ENDPOINT=https://api.ele.me
ELEME_API_KEY=your-eleme-api-key
ELEME_API_SECRET=your-eleme-api-secret
```

---

**文档版本**: v1.1  
**创建日期**: 2025-01-11  
**更新日期**: 2025-10-14  
**适用规模**: 10 万用户以内  
**预估成本**: ¥510/月  
**实施周期**: 2.5 周

**维护团队**: MyGarden 开发团队  
**最后更新**: 2025-10-14

---

## 版本更新记录

### v1.1 (2025-10-14)

**新增内容**：

- 新增 `meat_products` 集合（肉类碳足迹数据库）
- 81 种肉类产品数据（红肉/禽肉/水产/加工肉）
- 4 个 meat_products 集合索引
- 支持"素食 vs 肉食"对比计算功能

**集合总数**：12 个 → 13 个  
**索引总数**：28 个 → 32 个

**核心功能**：

- 碳排放对比计算
- 素食替代品推荐
- 减排量可视化展示

### v1.0 (2025-01-11)

**初始版本**：

- 12 个核心集合设计
- 28 个核心索引
- 基础安全方案
- 第三方同步支持
